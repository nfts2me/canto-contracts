/** ---------------------------------------------------------------------------- //
 *   Smart contract generated by https://nfts2me.com                             //
 *                                                                               //
 *   NFTs2Me is the most powerful NFT Art Generator                              //
 *   and resources for NFTs community.                                           //
 *                                                                               //
 *   NFTs2Me is not associated or affiliated with this project.                  //
 *   NFTs2Me is not liable for any bugs or issues associated with this contract. //
 * ----------------------------------------------------------------------------- */

/// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.18;

import "@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol";

import "@nfts2me/contracts/interfaces/IN2M_ERCCommon.sol";

import "./interfaces/IPaymaster.sol";
import "./N2MVersion.sol";

/// @title NFTs2Me.com Paymaster
/// @author The NFTs2Me Team
/// @notice Read our terms of service
/// @custom:security-contact security@nfts2me.com
/// @custom:terms-of-service https://nfts2me.com/terms-of-service/
/// @custom:website https://nfts2me.com/
contract N2M_Paymaster is Initializable, Ownable2StepUpgradeable, UUPSUpgradeable, IPaymaster {

    mapping(address => bool) private _swapRouters;
    mapping(bytes4 => bool) private _mintSelectors;

    address internal constant N2M_TREASURY = address(0x955aF4de9Ca03f84c9462457D075aCABf1A8AfC8);
    uint256[50] private __gap;

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    function initialize(address[] memory swapRouters, bytes4[] memory mintSelectors) public initializer {
        __Ownable_init();
        __UUPSUpgradeable_init();
        uint256 swapRoutersSize = swapRouters.length;
        for (uint256 i; i < swapRoutersSize; i++) {
            _swapRouters[swapRouters[i]] = true;
        }

        uint256 mintSelectorsSize = mintSelectors.length;
        for (uint256 i; i < mintSelectorsSize; i++) {
            _mintSelectors[mintSelectors[i]] = true;
        }        
    }

    function mintERC20UsingNative(
        address collection,
        bytes calldata mintPayload,
        address swapRouterAddress,
        bytes calldata swapPayload,
        uint256 erc20PaymentAmount,
        address erc20PaymentAddress
    ) external payable {
        bytes4 mintSelector;
        assembly {
            mintSelector := calldataload(mintPayload.offset)
        }
        require(_mintSelectors[mintSelector], 'Invalid selector');
        require(_swapRouters[swapRouterAddress], "Invalid swap router");

        (bool success, bytes memory returnData) = swapRouterAddress.call{value: msg.value}(swapPayload);
        if (success == false) {
            assembly {
                revert(add(returnData, 32), mload(returnData))
            }
        }

        IERC20Upgradeable(erc20PaymentAddress).approve(collection, erc20PaymentAmount);

        (success, returnData) = collection.call(mintPayload);
        if (success == false) {
            assembly {
                revert(add(returnData, 32), mload(returnData))
            }
        }        

        uint256 nativeBalance = address(this).balance;
        if (nativeBalance > 0) {
             msg.sender.call{value: nativeBalance}("");
        }

        uint256 erc20Balance = IERC20Upgradeable(erc20PaymentAddress).balanceOf(address(this));
        if (erc20Balance > 0) {
            try IERC20Upgradeable(erc20PaymentAddress).transfer(msg.sender, erc20Balance) { } catch { }
        }
    }


    function _authorizeUpgrade(address newImplementation)
        internal
        override
        onlyOwner
    {}
}
